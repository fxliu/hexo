---
title: 命令行
tags: 
  - 管道
  - 命令行
categories: 
  - VC
description: 管道, 命令行
date: 2019-11-26 18:05:20
updated: 2019-11-26 18:05:20
---

## API

```C++
BOOL GetInfoByCmd(CString &strResult, CString strCmd)
{
  BOOL bret = FALSE;

  HANDLE hOutRead, hOutWrite, hInRead, hInWrite;
  hOutRead = hOutWrite = hInRead = hInWrite = NULL;
  SECURITY_ATTRIBUTES sa;
  sa.nLength = sizeof(SECURITY_ATTRIBUTES);
  sa.lpSecurityDescriptor = NULL;
  sa.bInheritHandle = TRUE;
  //创建管道
  if (!CreatePipe(&hOutRead, &hOutWrite, &sa, 0))
    goto _end;
  if (!CreatePipe(&hInRead, &hInWrite, &sa, 0))
    goto _end;
  //控制命令行窗口信息
  STARTUPINFO si;
  ZeroMemory(&si, sizeof(si));
  si.cb = sizeof(STARTUPINFO);
  GetStartupInfo(&si);
  si.hStdInput = hInRead;
  si.hStdError = hOutWrite;
  si.hStdOutput = hOutWrite;
  si.wShowWindow = SW_HIDE; //隐藏命令行窗口
  si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
  //进程信息
  PROCESS_INFORMATION pi;
  ZeroMemory(&pi, sizeof(pi));

  //创建获取命令行进程
  if (strCmd.Find('\n') == -1)
  {
    // 单行指令
    TCHAR szCmd[256] = TEXT("cmd.exe /c");   // 必须单独申请变量，直接CreateProcess会崩溃，BUG？？
    StrCat(szCmd, strCmd);
    if (!CreateProcess(NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
      goto _end;
  }
  else
  {
    // 多行指令 - 最后一条指令必须是exit，否则进程无法退出
    // strCmd = TEXT("@echo off\ndir\nexit\n");
    TCHAR szCmd[32] = TEXT("cmd.exe");
    if (!CreateProcess(NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
      goto _end;
    if (strCmd.Right(1) != TEXT("\n"))
      strCmd += TEXT("\n");
    if (!WriteFile(hInWrite, CW2A(strCmd).m_psz, strCmd.GetLength(), NULL, NULL))
      goto _end;
  }
  // 等待进程结束
  WaitForSingleObject(pi.hProcess, INFINITE);
  CloseHandle(hOutWrite);   // 关闭Write，避免缓存数据读完后read阻塞
  hOutWrite = NULL;
  // 缓冲区数据读取
  const long MAX_OUT_SIZE = 1024;
  char szBuffer[MAX_OUT_SIZE + 1];
  memset(szBuffer, 0, sizeof(szBuffer));
  while (ReadFile(hOutRead, szBuffer, MAX_OUT_SIZE, NULL, 0))
  {
    strResult += CA2W(szBuffer);
    memset(szBuffer, 0, sizeof(szBuffer));
  }
  bret = TRUE;

  _end:
  //关闭所有的句柄
  if (hOutRead)
    CloseHandle(hOutRead);
  if (hOutWrite)
    CloseHandle(hOutWrite);
  if (hInRead)
    CloseHandle(hInRead);
  if (hInWrite)
    CloseHandle(hInWrite);
  if (pi.hProcess)
    CloseHandle(pi.hProcess);
  if (pi.hThread)
    CloseHandle(pi.hThread);
  return bret;
}
```
