---
title: 图片
tags: 
    - Bitmap
categories: 
    - Android
description: Bitmap
date: 2020-02-07 22:12:34
updated: 2020-02-07 22:12:34
---

## ImageView

```java
byte[] photoBytes;  // 二进制图片内存数据
ImageView imageView =this.findViewById(R.id.imageViewPhoto);
Bitmap bitmap = BitmapFactory.decodeByteArray(photoBytes, 0, photoBytes.length);
imageView.setImageBitmap(bitmap);

// ImageLayout
bmp = base64ToBitmap(strBase64);
ImageView iv = new ImageView(this);
iv.setImageBitmap(bmp);
mImageLayout.addView(iv, new LinearLayout.LayoutParams(300, 300));
```

## Bitmap

### 图片加载

```java
// base64 图片数据
static Bitmap base64ToBitmap(String base64Data) {
    byte[] bytes = Base64Utils.decode(base64Data, Base64Utils.NO_WRAP);
    return BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
}
```

### 图片拉伸

```java
/**
    * 尺寸缩放
    *
    * @param bitmap bitmap
    * @param w      width
    * @param h      height
    * @return scaleBitmap
    */
public static Bitmap scale(Bitmap bitmap, int w, int h) {
    if (bitmap == null) {
        return null;
    }
    int width = bitmap.getWidth();
    int height = bitmap.getHeight();
    Matrix matrix = new Matrix();
    float scaleWidth = ((float) w / width);
    float scaleHeight = ((float) h / height);
    matrix.postScale(scaleWidth, scaleHeight);
    return Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix, true);
}
/**
    * 等比压缩图片
    *
    * @param resBitmap 原图
    * @param desWidth  压缩后图片的宽度
    * @param desHeight 压缩后图片的高度
    * @return 压缩后的图片
    */
public static Bitmap calculateInSampleSize(Bitmap resBitmap, int desWidth, int desHeight) {
    int resWidth = resBitmap.getWidth();
    int resHeight = resBitmap.getHeight();
    if (resHeight > desHeight || resWidth > desWidth) {
        // 计算出实际宽高和目标宽高的比率
        final float heightRatio = (float) desHeight / (float) resHeight;
        final float widthRatio = (float) desWidth / (float) resWidth;
        float scale = heightRatio < widthRatio ? heightRatio : widthRatio;
        return scale(resBitmap, scale);
    }
    return resBitmap;
}
```

### 图片比例缩放 / 质量压缩

```java
/**
    * 等比压缩图片
    *
    * @param bitmap 原图
    * @param scale  压缩因子
    * @return 压缩后的图片
    */
private static Bitmap scale(Bitmap bitmap, float scale) {
    Matrix matrix = new Matrix();
    matrix.postScale(scale, scale);
    return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
}

/**
    * 质量压缩
    * @param bitmap 被压缩的图片
    * @param sizeLimit 大小限制
    * @return 压缩后的图片
    */
private Bitmap compressBitmap(Bitmap bitmap, long sizeLimit) {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    int quality = 100;
    bitmap.compress(Bitmap.CompressFormat.JPEG, quality, baos);

    // 循环判断压缩后图片是否超过限制大小
    while(baos.toByteArray().length / 1024 > sizeLimit) {
        // 清空baos
        baos.reset();
        bitmap.compress(Bitmap.CompressFormat.JPEG, quality, baos);
        quality -= 10;
    }

    Bitmap newBitmap = BitmapFactory.decodeStream(new ByteArrayInputStream(baos.toByteArray()), null, null);

    return newBitmap;
}
// 将色彩模式换成RGB_565也会比默认的ARGB8888降低一半质量
BitmapFactory.Options options = new BitmapFactory.Options();
options.inPreferredConfig = Bitmap.Config.RGB_565;
bm = BitmapFactory.decodeFile(filePath, options);

// 质量压缩：百度
/**
    * @param bitmap  图片
    * @param quality 生成的JPG的质量
    * @param maxSize 最大边像素数
    * @return base64编码的数据
    */
public static String bitmapToJpegBase64(Bitmap bitmap, int quality, float maxSize) {
    try {
        float scale = maxSize / Math.max(bitmap.getWidth(), bitmap.getHeight());
        if (scale < 1) {
            bitmap = scale(bitmap, scale);
        }
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        bitmap.compress(CompressFormat.JPEG, quality, out);
        byte[] data = out.toByteArray();
        out.close();

        return Base64Utils.encodeToString(data, Base64Utils.NO_WRAP);
    } catch (Exception e) {
        return null;
    }
}

```

### 图片裁剪

```java
/**
    * 裁剪
    *
    * @param bitmap 原图
    * @return 裁剪后的图像
    */
private Bitmap cropBitmap(Bitmap bitmap) {
    int w = bitmap.getWidth(); // 得到图片的宽，高
    int h = bitmap.getHeight();
    int cropWidth = w >= h ? h : w;// 裁切后所取的正方形区域边长
    cropWidth /= 2;
    int cropHeight = (int) (cropWidth / 1.2);
    return Bitmap.createBitmap(bitmap, w / 3, 0, cropWidth, cropHeight, null, false);
}
```

### 图片旋转 / 偏移

```java
/**
    * 选择变换
    *
    * @param origin 原图
    * @param alpha  旋转角度，可正可负
    * @return 旋转后的图片
    */
private Bitmap rotateBitmap(Bitmap origin, float alpha) {
    if (origin == null) {
        return null;
    }
    int width = origin.getWidth();
    int height = origin.getHeight();
    Matrix matrix = new Matrix();
    matrix.setRotate(alpha);
    // 围绕原地进行旋转
    Bitmap newBM = Bitmap.createBitmap(origin, 0, 0, width, height, matrix, false);
    if (newBM.equals(origin)) {
        return newBM;
    }
    origin.recycle();
    return newBM;
}

/**
    * 偏移效果
    * @param origin 原图
    * @return 偏移后的bitmap
    */
private Bitmap skewBitmap(Bitmap origin) {
    if (origin == null) {
        return null;
    }
    int width = origin.getWidth();
    int height = origin.getHeight();
    Matrix matrix = new Matrix();
    matrix.postSkew(-0.6f, -0.3f);
    Bitmap newBM = Bitmap.createBitmap(origin, 0, 0, width, height, matrix, false);
    if (newBM.equals(origin)) {
        return newBM;
    }
    origin.recycle();
    return newBM;
}
```
