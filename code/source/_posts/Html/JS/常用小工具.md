---
title: 工具集
tags: 
  - 工具集
categories: 
  - JS
description: 工具集
date: 2020-04-03 17:47:42
updated: 2020-04-03 17:47:42
---

## 数组

```js
function getUrlKey(name) {
    let parames = new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(location.href);
    if(parames)
        return decodeURIComponent(parames[1].replace(/\+/g, '%20'));
    return "";
};
```

## 异步请求链

```js
// Promise对象，必须调用(resolve, reject)其中一个，否则不会继续下一个then
new Promise(function (resolve, reject) {
    ajax().done(function (d) {
        resolve(d);
    }).fail(function (d) {
        reject(d);
    });
}).then(function (d) {
    // resolve 事件
}).catch(error => {
    // reject 事件
});
// 小技巧: 先catch然后then
new Promise(function (resolve, reject) {
    // ...
}).catch(error => {
    // reject 事件
}).then(function (d) {
    // 这里的then一定会被调用
    // 如果异常，then接收catch的返回值
    // 如果未异常，then接收 Promise 的 resolve 事件
});

// 写法1
new Promise(function (resolve, reject) {
    // ...
}).then(function(d) {
    // 接收 resolve 事件
}, function(d) {
    // catch存在时，该函数无效
}).catch(error => {
    // 异常处理
    // 优点：前面链条中任何一步出现reject，均会中断，并跳转到catch
    // catch 也可以 return new Promise 继续链条
}).then(...);

// 写法2：
new Promise(function (resolve, reject) {
    // ...
}).then(function(d) {
    // 接收resolve事件
}, function(d) {
    // 接收reject事件
    // 有点：可以自定义处理，继续 return new Promise 给后面的链条
}).then(...);

// 写法3：then, catch 非异步情况，也可以直接链式调用
// 出错就跳转到下一个catch，可以当做try catch使用
// 未出错，则继续调用下一个then
// 若上一个then 无return，则下一个then的接收值为 undefine
new Promise(function (resolve, reject) {
    // ...
}).then(...).catch()
.then(...)
.then(...)
.then(...);
```
